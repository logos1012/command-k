/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugin's github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CmdKPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var PRICING_PER_MILLION_TOKENS = {
  openai: {
    "gpt-5.2": { input: 15, output: 60 },
    "gpt-5.2-pro": { input: 30, output: 120 },
    "gpt-5.1": { input: 10, output: 40 },
    "gpt-5": { input: 8, output: 32 },
    "gpt-5-mini": { input: 2, output: 8 },
    "gpt-5-nano": { input: 0.5, output: 2 },
    "gpt-5-pro": { input: 20, output: 80 },
    "gpt-4.1": { input: 5, output: 20 },
    "gpt-4.1-mini": { input: 1, output: 4 },
    "gpt-4.1-nano": { input: 0.3, output: 1.2 },
    "gpt-4o": { input: 2.5, output: 10 },
    "gpt-4o-mini": { input: 0.15, output: 0.6 },
    "o3": { input: 100, output: 400 },
    "o3-pro": { input: 200, output: 800 },
    "o4-mini": { input: 0.1, output: 0.4 },
    "o1": { input: 15, output: 60 },
    "o1-pro": { input: 30, output: 120 },
    "o1-mini": { input: 3, output: 12 }
  },
  gemini: {
    "gemini-1.5-flash": { input: 0.075, output: 0.3 },
    "gemini-1.5-pro": { input: 1.25, output: 5 },
    "gemini-2.0-flash": { input: 0.075, output: 0.3 }
  },
  claude: {
    "claude-3-5-sonnet-20241022": { input: 3, output: 15 },
    "claude-3-opus-20240229": { input: 15, output: 75 },
    "claude-3-haiku-20240307": { input: 0.25, output: 1.25 }
  }
};
var DEFAULT_SETTINGS = {
  aiProvider: "openai",
  openaiApiKey: "",
  openaiModel: "gpt-4o-mini",
  geminiApiKey: "",
  geminiModel: "gemini-1.5-flash",
  claudeApiKey: "",
  claudeModel: "claude-3-haiku-20240307",
  maxTokens: 7e3,
  savedPrompts: [
    {
      id: "1",
      name: "Fix Grammar",
      prompt: "Fix grammar and spelling errors",
      category: "Writing",
      createdAt: Date.now(),
      usageCount: 0
    },
    {
      id: "2",
      name: "Make Concise",
      prompt: "Make this text more concise while keeping the main points",
      category: "Writing",
      createdAt: Date.now(),
      usageCount: 0
    },
    {
      id: "3",
      name: "Translate to Korean",
      prompt: "Translate this text to Korean",
      category: "Translation",
      createdAt: Date.now(),
      usageCount: 0
    }
  ],
  recentPrompts: [],
  maxRecentPrompts: 5
};

// src/settings.ts
var import_obsidian = require("obsidian");
function formatCost(input, output) {
  return `$${input}/$${output} per 1M tokens`;
}
function getOpenAIModelLabel(model) {
  const pricing = PRICING_PER_MILLION_TOKENS.openai[model];
  const labels = {
    "gpt-5.2": "GPT-5.2",
    "gpt-5.2-pro": "GPT-5.2 Pro",
    "gpt-5.1": "GPT-5.1",
    "gpt-5": "GPT-5",
    "gpt-5-mini": "GPT-5 Mini",
    "gpt-5-nano": "GPT-5 Nano",
    "gpt-5-pro": "GPT-5 Pro",
    "gpt-4.1": "GPT-4.1",
    "gpt-4.1-mini": "GPT-4.1 Mini",
    "gpt-4.1-nano": "GPT-4.1 Nano",
    "gpt-4o": "GPT-4o",
    "gpt-4o-mini": "GPT-4o Mini",
    "o3": "o3",
    "o3-pro": "o3 Pro",
    "o4-mini": "o4 Mini",
    "o1": "o1",
    "o1-pro": "o1 Pro",
    "o1-mini": "o1 Mini"
  };
  return `${labels[model]} (${formatCost(pricing.input, pricing.output)})`;
}
function getGeminiModelLabel(model) {
  const pricing = PRICING_PER_MILLION_TOKENS.gemini[model];
  const labels = {
    "gemini-1.5-flash": "Gemini 1.5 Flash",
    "gemini-1.5-pro": "Gemini 1.5 Pro",
    "gemini-2.0-flash": "Gemini 2.0 Flash"
  };
  return `${labels[model]} (${formatCost(pricing.input, pricing.output)})`;
}
function getClaudeModelLabel(model) {
  const pricing = PRICING_PER_MILLION_TOKENS.claude[model];
  const labels = {
    "claude-3-5-sonnet-20241022": "Claude 3.5 Sonnet",
    "claude-3-opus-20240229": "Claude 3 Opus",
    "claude-3-haiku-20240307": "Claude 3 Haiku"
  };
  return `${labels[model]} (${formatCost(pricing.input, pricing.output)})`;
}
var PromptManagementModal = class extends import_obsidian.Modal {
  constructor(app, prompts, onSave) {
    super(app);
    this.prompts = [...prompts];
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Manage Saved Prompts" });
    const promptList = contentEl.createDiv({ cls: "prompt-management-list" });
    this.prompts.forEach((prompt, index) => {
      const promptItem = promptList.createDiv({ cls: "prompt-management-item" });
      new import_obsidian.Setting(promptItem).setName(prompt.name).setDesc(`${prompt.prompt} (Used ${prompt.usageCount} times)`).addButton((btn) => btn.setButtonText("Delete").setWarning().onClick(() => {
        this.prompts.splice(index, 1);
        this.onOpen();
      }));
    });
    const buttonDiv = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonDiv).setButtonText("Save Changes").setCta().onClick(() => {
      this.onSave(this.prompts);
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonDiv).setButtonText("Cancel").onClick(() => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CmdKSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "EditorK Settings" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select the AI provider to use for text editing").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI (ChatGPT)").addOption("gemini", "Google Gemini").addOption("claude", "Anthropic Claude").setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
      this.plugin.settings.aiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiProvider === "openai") {
      containerEl.createEl("h3", { text: "OpenAI Settings" });
      new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      }).inputEl.type = "password");
      new import_obsidian.Setting(containerEl).setName("OpenAI Model").setDesc("Model for text editing. Cost shown as input/output per 1M tokens.").addDropdown((dropdown) => {
        const models = [
          "gpt-5.2",
          "gpt-5.2-pro",
          "gpt-5.1",
          "gpt-5",
          "gpt-5-mini",
          "gpt-5-nano",
          "gpt-5-pro",
          "gpt-4.1",
          "gpt-4.1-mini",
          "gpt-4.1-nano",
          "gpt-4o",
          "gpt-4o-mini",
          "o3",
          "o3-pro",
          "o4-mini",
          "o1",
          "o1-pro",
          "o1-mini"
        ];
        models.forEach((model) => {
          dropdown.addOption(model, getOpenAIModelLabel(model));
        });
        dropdown.setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
          this.plugin.settings.openaiModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
    if (this.plugin.settings.aiProvider === "gemini") {
      containerEl.createEl("h3", { text: "Google Gemini Settings" });
      new import_obsidian.Setting(containerEl).setName("Gemini API Key").setDesc("Your Google Gemini API key").addText((text) => text.setPlaceholder("API key").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        await this.plugin.saveSettings();
      }).inputEl.type = "password");
      new import_obsidian.Setting(containerEl).setName("Gemini Model").setDesc("Model for text editing. Cost shown as input/output per 1M tokens.").addDropdown((dropdown) => {
        const models = ["gemini-1.5-flash", "gemini-1.5-pro", "gemini-2.0-flash"];
        models.forEach((model) => {
          dropdown.addOption(model, getGeminiModelLabel(model));
        });
        dropdown.setValue(this.plugin.settings.geminiModel).onChange(async (value) => {
          this.plugin.settings.geminiModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
    if (this.plugin.settings.aiProvider === "claude") {
      containerEl.createEl("h3", { text: "Anthropic Claude Settings" });
      new import_obsidian.Setting(containerEl).setName("Claude API Key").setDesc("Your Anthropic Claude API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
        this.plugin.settings.claudeApiKey = value;
        await this.plugin.saveSettings();
      }).inputEl.type = "password");
      new import_obsidian.Setting(containerEl).setName("Claude Model").setDesc("Model for text editing. Cost shown as input/output per 1M tokens.").addDropdown((dropdown) => {
        const models = [
          "claude-3-5-sonnet-20241022",
          "claude-3-opus-20240229",
          "claude-3-haiku-20240307"
        ];
        models.forEach((model) => {
          dropdown.addOption(model, getClaudeModelLabel(model));
        });
        dropdown.setValue(this.plugin.settings.claudeModel).onChange(async (value) => {
          this.plugin.settings.claudeModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum number of tokens for AI processing (max: 7000)").addText((text) => text.setPlaceholder("7000").setValue(String(this.plugin.settings.maxTokens)).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxTokens = Math.min(numValue, 7e3);
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Prompt Management" });
    new import_obsidian.Setting(containerEl).setName("Saved Prompts").setDesc("Manage your saved prompts for quick access").addButton((button) => {
      var _a;
      return button.setButtonText(`Manage Prompts (${((_a = this.plugin.settings.savedPrompts) == null ? void 0 : _a.length) || 0})`).onClick(() => {
        const modal = new PromptManagementModal(
          this.app,
          this.plugin.settings.savedPrompts || [],
          async (prompts) => {
            this.plugin.settings.savedPrompts = prompts;
            await this.plugin.saveSettings();
            this.display();
          }
        );
        modal.open();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Max Recent Prompts").setDesc("Maximum number of recent prompts to remember").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.maxRecentPrompts || 5)).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxRecentPrompts = Math.min(numValue, 20);
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Keyboard Shortcuts" });
    const shortcutInfo = containerEl.createDiv();
    shortcutInfo.createEl("p", {
      text: "Default shortcuts:"
    });
    shortcutInfo.createEl("ul").innerHTML = `
            <li><strong>Ctrl + Shift + K</strong>: Edit selected text with AI</li>
            <li><strong>Alt + E</strong>: Alternative shortcut for editing</li>
        `;
    shortcutInfo.createEl("p", {
      text: 'You can customize these in Settings \u2192 Hotkeys \u2192 Search for "EditorK"'
    });
  }
};

// src/ui/prompt-modal.ts
var import_obsidian2 = require("obsidian");
var PromptModal = class extends import_obsidian2.Modal {
  constructor(app, selectedText, savedPrompts, onSubmit, onSavePrompt, onDeletePrompt) {
    super(app);
    this.prompt = "";
    this.selectedText = selectedText;
    this.savedPrompts = savedPrompts;
    this.onSubmit = onSubmit;
    this.onSavePrompt = onSavePrompt;
    this.onDeletePrompt = onDeletePrompt;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.addClass("editor-k-prompt-modal");
    if (modalEl) {
      modalEl.style.width = "800px";
      modalEl.style.maxWidth = "90vw";
      modalEl.style.left = "50%";
      modalEl.style.right = "auto";
      modalEl.style.transform = "translateX(-50%)";
      modalEl.style.marginLeft = "0";
      modalEl.style.marginRight = "0";
    }
    contentEl.createEl("h2", { text: "EditorK: AI Text Editor" });
    const mainContainer = contentEl.createDiv({ cls: "editor-k-main-container" });
    const topSection = mainContainer.createDiv({ cls: "editor-k-top-section" });
    const previewDiv = topSection.createDiv({ cls: "cmd-k-preview" });
    previewDiv.createEl("h4", { text: "Selected Text:" });
    const textPreview = this.selectedText.length > 200 ? this.selectedText.substring(0, 200) + "..." : this.selectedText;
    previewDiv.createEl("pre", {
      text: textPreview,
      cls: "cmd-k-selected-text"
    });
    const promptDiv = topSection.createDiv({ cls: "cmd-k-prompt" });
    promptDiv.createEl("h4", { text: "What would you like to do?" });
    this.textArea = new import_obsidian2.TextAreaComponent(promptDiv);
    this.textArea.inputEl.style.width = "100%";
    this.textArea.inputEl.style.minHeight = "100px";
    this.textArea.inputEl.placeholder = 'e.g., "Make it more concise", "Fix grammar", "Translate to Spanish"...';
    this.textArea.onChange((value) => {
      this.prompt = value;
    });
    const savePromptDiv = topSection.createDiv({ cls: "editor-k-save-prompt" });
    savePromptDiv.createEl("p", {
      text: "Save current prompt for quick access later",
      cls: "editor-k-save-hint"
    });
    const savePromptContainer = savePromptDiv.createDiv({ cls: "editor-k-save-container" });
    const promptNameInput = new import_obsidian2.TextComponent(savePromptContainer);
    promptNameInput.setPlaceholder("Prompt name (e.g., Fix Grammar)");
    promptNameInput.inputEl.style.flex = "1";
    promptNameInput.inputEl.style.marginRight = "8px";
    const categoryInput = new import_obsidian2.TextComponent(savePromptContainer);
    categoryInput.setPlaceholder("Category (optional)");
    categoryInput.inputEl.style.width = "150px";
    categoryInput.inputEl.style.marginRight = "8px";
    const savePromptBtn = new import_obsidian2.ButtonComponent(savePromptContainer);
    savePromptBtn.setButtonText("Save").onClick(async () => {
      if (this.prompt.trim() && promptNameInput.getValue().trim()) {
        const newPrompt = {
          id: Date.now().toString(),
          name: promptNameInput.getValue(),
          prompt: this.prompt,
          category: categoryInput.getValue() || "General",
          createdAt: Date.now(),
          usageCount: 0
        };
        this.savedPrompts.push(newPrompt);
        await this.onSavePrompt(newPrompt);
        this.updatePromptList();
        promptNameInput.setValue("");
        categoryInput.setValue("");
      } else if (!this.prompt.trim()) {
        alert("Please enter a prompt first!");
      } else {
        alert("Please enter a prompt name!");
      }
    });
    this.textArea.inputEl.focus();
    const bottomSection = mainContainer.createDiv({ cls: "editor-k-bottom-section" });
    bottomSection.createEl("h4", { text: "Saved Prompts" });
    this.promptListEl = bottomSection.createDiv({ cls: "editor-k-prompt-list" });
    this.updatePromptList();
    const buttonDiv = contentEl.createDiv({ cls: "cmd-k-buttons" });
    const submitButton = new import_obsidian2.ButtonComponent(buttonDiv);
    submitButton.setButtonText("Process").setCta().onClick(() => {
      if (this.prompt.trim()) {
        this.close();
        this.onSubmit(this.prompt);
      } else {
        alert("Please enter a prompt!");
      }
    });
    const cancelButton = new import_obsidian2.ButtonComponent(buttonDiv);
    cancelButton.setButtonText("Cancel").onClick(() => {
      this.close();
    });
    this.textArea.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey && e.ctrlKey) {
        e.preventDefault();
        if (this.prompt.trim()) {
          this.close();
          this.onSubmit(this.prompt);
        }
      }
    });
  }
  updatePromptList() {
    this.promptListEl.empty();
    const promptsByCategory = {};
    this.savedPrompts.forEach((prompt) => {
      const category = prompt.category || "General";
      if (!promptsByCategory[category]) {
        promptsByCategory[category] = [];
      }
      promptsByCategory[category].push(prompt);
    });
    Object.keys(promptsByCategory).forEach((category) => {
      promptsByCategory[category].sort((a, b) => b.usageCount - a.usageCount);
    });
    Object.keys(promptsByCategory).sort().forEach((category) => {
      const categoryEl = this.promptListEl.createDiv({ cls: "editor-k-category" });
      categoryEl.createEl("h5", { text: category, cls: "editor-k-category-title" });
      const categoryItems = categoryEl.createDiv({ cls: "editor-k-category-items" });
      promptsByCategory[category].forEach((savedPrompt) => {
        const promptItemEl = categoryItems.createDiv({ cls: "editor-k-prompt-item" });
        promptItemEl.onclick = (e) => {
          if (!e.target.closest(".editor-k-delete-btn")) {
            this.textArea.setValue(savedPrompt.prompt);
            this.prompt = savedPrompt.prompt;
            this.textArea.inputEl.focus();
          }
        };
        const promptContent = promptItemEl.createDiv({ cls: "editor-k-prompt-content" });
        promptContent.createEl("span", {
          text: savedPrompt.name,
          cls: "editor-k-prompt-name"
        });
        if (savedPrompt.usageCount > 0) {
          promptContent.createEl("span", {
            text: `(${savedPrompt.usageCount})`,
            cls: "editor-k-usage-count"
          });
        }
        const buttonContainer = promptItemEl.createDiv({ cls: "editor-k-prompt-buttons" });
        const deleteButton = new import_obsidian2.ButtonComponent(buttonContainer);
        deleteButton.setButtonText("\xD7").setClass("editor-k-delete-btn").setTooltip("Delete this prompt").onClick(() => {
          if (confirm(`Delete prompt "${savedPrompt.name}"?`)) {
            this.onDeletePrompt(savedPrompt.id);
            this.savedPrompts = this.savedPrompts.filter((p) => p.id !== savedPrompt.id);
            this.updatePromptList();
          }
        });
      });
    });
    if (this.savedPrompts.length === 0) {
      this.promptListEl.createEl("p", {
        text: "No saved prompts yet. Save your frequently used prompts for quick access!",
        cls: "editor-k-no-prompts"
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/diff-viewer.ts
var import_obsidian3 = require("obsidian");

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/util/string.js
function longestCommonPrefix(str1, str2) {
  let i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  let i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  let startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  let endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  const map = Array(endB);
  let k = 0;
  map[0] = 0;
  for (let j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (let i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
function trailingWs(string) {
  let i;
  for (i = string.length - 1; i >= 0; i--) {
    if (!string[i].match(/\s/)) {
      break;
    }
  }
  return string.substring(i + 1);
}
function leadingWs(string) {
  const match = string.match(/^\s*/);
  return match ? match[0] : "";
}

// node_modules/diff/libesm/diff/word.js
var extendedWordChars = "a-zA-Z0-9_\\u{AD}\\u{C0}-\\u{D6}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`, "ug");
var WordDiff = class extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word") {
        throw new Error('The segmenter passed must have a granularity of "word"');
      }
      parts = [];
      for (const segmentObj of Array.from(segmenter.segment(value))) {
        const segment = segmentObj.segment;
        if (parts.length && /\s/.test(parts[parts.length - 1]) && /\s/.test(segment)) {
          parts[parts.length - 1] += segment;
        } else {
          parts.push(segment);
        }
      }
    } else {
      parts = value.match(tokenizeIncludingWhitespace) || [];
    }
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part)) {
        if (prevPart == null) {
          tokens.push(part);
        } else {
          tokens.push(tokens.pop() + part);
        }
      } else if (prevPart != null && /\s/.test(prevPart)) {
        if (tokens[tokens.length - 1] == prevPart) {
          tokens.push(tokens.pop() + part);
        } else {
          tokens.push(prevPart + part);
        }
      } else {
        tokens.push(part);
      }
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens.map((token, i) => {
      if (i == 0) {
        return token;
      } else {
        return token.replace(/^\s+/, "");
      }
    }).join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) {
      return changes;
    }
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) {
        insertion = change;
      } else if (change.removed) {
        deletion = change;
      } else {
        if (insertion || deletion) {
          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
        }
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion) {
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    }
    return changes;
  }
};
var wordDiff = new WordDiff();
function diffWords(oldStr, newStr, options) {
  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options);
  }
  return wordDiff.diff(oldStr, newStr, options);
}
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}
var WordsWithSpaceDiff = class extends Diff {
  tokenize(value) {
    const regex = new RegExp(`(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`, "ug");
    return value.match(regex) || [];
  }
};
var wordsWithSpaceDiff = new WordsWithSpaceDiff();
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordsWithSpaceDiff.diff(oldStr, newStr, options);
}

// src/ui/diff-viewer.ts
var DiffViewer = class extends import_obsidian3.Modal {
  constructor(app, originalText, modifiedText, onAccept, onReject) {
    super(app);
    this.originalText = originalText;
    this.modifiedText = modifiedText;
    this.onAccept = onAccept;
    this.onReject = onReject;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Review Changes" });
    const diffContainer = contentEl.createDiv({ cls: "cmd-k-diff-container" });
    const changes = diffWords(this.originalText, this.modifiedText);
    const diffDisplay = diffContainer.createDiv({ cls: "cmd-k-diff-display" });
    changes.forEach((part) => {
      const span = diffDisplay.createEl("span");
      if (part.added) {
        span.addClass("cmd-k-diff-added");
        span.textContent = part.value;
      } else if (part.removed) {
        span.addClass("cmd-k-diff-removed");
        span.textContent = part.value;
      } else {
        span.addClass("cmd-k-diff-unchanged");
        span.textContent = part.value;
      }
    });
    const statsDiv = contentEl.createDiv({ cls: "cmd-k-diff-stats" });
    const addedChars = changes.filter((c) => c.added).reduce((sum, c) => {
      var _a;
      return sum + (((_a = c.value) == null ? void 0 : _a.length) || 0);
    }, 0);
    const removedChars = changes.filter((c) => c.removed).reduce((sum, c) => {
      var _a;
      return sum + (((_a = c.value) == null ? void 0 : _a.length) || 0);
    }, 0);
    statsDiv.createEl("small", {
      text: `Added: ${addedChars} characters | Removed: ${removedChars} characters`
    });
    const buttonDiv = contentEl.createDiv({ cls: "cmd-k-buttons" });
    const acceptButton = new import_obsidian3.ButtonComponent(buttonDiv);
    acceptButton.setButtonText("Accept").setCta().onClick(() => {
      this.close();
      this.onAccept();
    });
    const rejectButton = new import_obsidian3.ButtonComponent(buttonDiv);
    rejectButton.setButtonText("Reject").setWarning().onClick(() => {
      this.close();
      this.onReject();
    });
    this.scope.register([], "Enter", () => {
      this.close();
      this.onAccept();
      return false;
    });
    this.scope.register([], "Escape", () => {
      this.close();
      this.onReject();
      return false;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ai/provider.ts
var BaseAIProvider = class {
  constructor(maxTokens = 7e3) {
    this.maxTokens = Math.min(maxTokens, 7e3);
  }
  getMaxTokens() {
    return this.maxTokens;
  }
  estimateTokenCount(text) {
    return Math.ceil(text.length / 4);
  }
  validateTokenLimit(text) {
    return this.estimateTokenCount(text) <= this.maxTokens;
  }
};

// src/ai/openai.ts
var OpenAIProvider = class extends BaseAIProvider {
  constructor(apiKey, model, maxTokens) {
    super(maxTokens);
    this.apiKey = apiKey;
    this.model = model;
  }
  async processText(selectedText, prompt) {
    var _a;
    if (!this.validateSettings()) {
      throw new Error("OpenAI API key is not configured");
    }
    if (!this.validateTokenLimit(selectedText + prompt)) {
      throw new Error(`Text exceeds maximum token limit of ${this.maxTokens}`);
    }
    const systemPrompt = `You are an AI assistant helping to edit text.
        You will receive a selected text and a user prompt.
        Your task is to modify the selected text according to the user's instructions.
        Return ONLY the modified text without any explanations or additional formatting.`;
    const userContent = `Selected Text:
${selectedText}

User Request: ${prompt}`;
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userContent }
          ],
          max_tokens: this.maxTokens,
          temperature: 0.7
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API Error: ${((_a = error.error) == null ? void 0 : _a.message) || response.statusText}`);
      }
      const data = await response.json();
      const modifiedText = data.choices[0].message.content.trim();
      return modifiedText;
    } catch (error) {
      console.error("OpenAI API Error:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to process text with OpenAI");
    }
  }
  validateSettings() {
    return !!this.apiKey && this.apiKey.trim() !== "";
  }
};

// src/ai/gemini.ts
var GeminiProvider = class extends BaseAIProvider {
  constructor(apiKey, model, maxTokens) {
    super(maxTokens);
    this.apiKey = apiKey;
    this.model = model;
  }
  async processText(selectedText, prompt) {
    var _a;
    if (!this.validateSettings()) {
      throw new Error("Gemini API key is not configured");
    }
    if (!this.validateTokenLimit(selectedText + prompt)) {
      throw new Error(`Text exceeds maximum token limit of ${this.maxTokens}`);
    }
    const systemInstruction = `You are an AI assistant helping to edit text.
        You will receive a selected text and a user prompt.
        Your task is to modify the selected text according to the user's instructions.
        Return ONLY the modified text without any explanations or additional formatting.`;
    const userContent = `Selected Text:
${selectedText}

User Request: ${prompt}`;
    try {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents: [
              {
                parts: [
                  { text: `${systemInstruction}

${userContent}` }
                ]
              }
            ],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: this.maxTokens
            }
          })
        }
      );
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Gemini API Error: ${((_a = error.error) == null ? void 0 : _a.message) || response.statusText}`);
      }
      const data = await response.json();
      const modifiedText = data.candidates[0].content.parts[0].text.trim();
      return modifiedText;
    } catch (error) {
      console.error("Gemini API Error:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to process text with Gemini");
    }
  }
  validateSettings() {
    return !!this.apiKey && this.apiKey.trim() !== "";
  }
};

// src/ai/claude.ts
var ClaudeProvider = class extends BaseAIProvider {
  constructor(apiKey, model, maxTokens) {
    super(maxTokens);
    this.apiKey = apiKey;
    this.model = model;
  }
  async processText(selectedText, prompt) {
    var _a;
    if (!this.validateSettings()) {
      throw new Error("Claude API key is not configured");
    }
    if (!this.validateTokenLimit(selectedText + prompt)) {
      throw new Error(`Text exceeds maximum token limit of ${this.maxTokens}`);
    }
    const systemPrompt = `You are an AI assistant helping to edit text.
        You will receive a selected text and a user prompt.
        Your task is to modify the selected text according to the user's instructions.
        Return ONLY the modified text without any explanations or additional formatting.`;
    const userContent = `Selected Text:
${selectedText}

User Request: ${prompt}`;
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: this.model,
          max_tokens: this.maxTokens,
          messages: [
            {
              role: "user",
              content: userContent
            }
          ],
          system: systemPrompt,
          temperature: 0.7
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Claude API Error: ${((_a = error.error) == null ? void 0 : _a.message) || response.statusText}`);
      }
      const data = await response.json();
      const modifiedText = data.content[0].text.trim();
      return modifiedText;
    } catch (error) {
      console.error("Claude API Error:", error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error("Failed to process text with Claude");
    }
  }
  validateSettings() {
    return !!this.apiKey && this.apiKey.trim() !== "";
  }
};

// src/main.ts
var CmdKPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.ribbonIcon = null;
  }
  async onload() {
    await this.loadSettings();
    this.loadStyles();
    this.ribbonIcon = this.addRibbonIcon(
      "wand-2",
      "EditorK: Edit with AI",
      (evt) => {
        this.handleEditorK();
      }
    );
    this.addCommand({
      id: "editor-k-edit",
      name: "Edit selected text with AI",
      editorCallback: (editor, view) => {
        this.handleEditorKFromEditor(editor);
      },
      hotkeys: [
        {
          modifiers: ["Ctrl", "Shift"],
          key: "k"
        }
      ]
    });
    this.addCommand({
      id: "editor-k-edit-alt",
      name: "Edit selected text with AI (Alternative)",
      editorCallback: (editor, view) => {
        this.handleEditorKFromEditor(editor);
      },
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "e"
        }
      ]
    });
    this.addSettingTab(new CmdKSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    if (!Array.isArray(this.settings.savedPrompts)) {
      this.settings.savedPrompts = DEFAULT_SETTINGS.savedPrompts;
    }
    if (!Array.isArray(this.settings.recentPrompts)) {
      this.settings.recentPrompts = [];
    }
    if (!this.settings.maxRecentPrompts) {
      this.settings.maxRecentPrompts = 5;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "editor-k-styles";
    styleEl.textContent = `
            /* EditorK Plugin Styles */

            /* Modal Layout */
            .editor-k-prompt-modal {
                width: 800px !important;
                max-width: 90vw !important;
            }

            .modal:has(.editor-k-prompt-modal) {
                width: 800px !important;
                max-width: 90vw !important;
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important;
            }

            .modal-container:has(.editor-k-prompt-modal) {
                width: 800px !important;
                max-width: 90vw !important;
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important;
            }

            .editor-k-main-container {
                display: flex;
                flex-direction: column;
                gap: 20px;
                margin-bottom: 1rem;
            }

            .editor-k-top-section {
                width: 100%;
            }

            .editor-k-bottom-section {
                width: 100%;
                border-top: 1px solid var(--background-modifier-border);
                padding-top: 20px;
                max-height: 300px;
                overflow-y: auto;
            }

            /* Save Prompt Section */
            .editor-k-save-prompt {
                margin-top: 1rem;
                padding-top: 1rem;
                border-top: 1px solid var(--background-modifier-border);
            }

            .editor-k-save-hint {
                font-size: 0.9em;
                color: var(--text-muted);
                margin-bottom: 0.5rem;
            }

            .editor-k-save-container {
                display: flex;
                align-items: center;
                gap: 8px;
                flex-wrap: nowrap;
            }

            .editor-k-save-container input[type="text"] {
                box-sizing: border-box;
            }

            /* Prompt List */
            .editor-k-prompt-list {
                margin-top: 0.5rem;
            }

            .editor-k-category {
                margin-bottom: 1.5rem;
            }

            .editor-k-category-title {
                color: var(--text-muted);
                font-size: 0.9em;
                margin: 0 0 0.75rem 0;
                font-weight: 600;
            }

            .editor-k-category-items {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }

            .editor-k-prompt-item {
                background: var(--background-secondary);
                padding: 0.5rem 0.75rem;
                border-radius: 6px;
                display: inline-flex;
                align-items: center;
                gap: 8px;
                transition: background 0.2s;
                cursor: pointer;
                flex-shrink: 0;
            }

            .editor-k-prompt-item:hover {
                background: var(--background-secondary-alt);
            }

            .editor-k-prompt-content {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .editor-k-prompt-name {
                font-weight: 500;
                color: var(--text-normal);
                white-space: nowrap;
            }

            .editor-k-usage-count {
                font-size: 0.75em;
                color: var(--text-faint);
                white-space: nowrap;
            }

            .editor-k-prompt-buttons {
                display: flex;
                gap: 4px;
                align-items: center;
            }

            .editor-k-delete-btn {
                background: transparent !important;
                color: var(--text-error) !important;
                font-size: 1.2em !important;
                padding: 0 8px !important;
                min-width: auto !important;
            }

            .editor-k-no-prompts {
                color: var(--text-muted);
                font-style: italic;
                text-align: center;
                padding: 1rem;
            }

            /* CMD-K Plugin Styles */

            /* Prompt Modal Styles */
            .cmd-k-preview {
                margin-bottom: 1rem;
            }

            .cmd-k-selected-text {
                background-color: var(--background-secondary);
                padding: 0.5rem;
                border-radius: 4px;
                font-size: 0.9em;
                max-height: 150px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-break: break-word;
                overflow-x: hidden;
            }

            .cmd-k-prompt {
                margin-bottom: 1rem;
            }

            .cmd-k-prompt textarea {
                width: 100% !important;
                min-height: 100px !important;
                resize: vertical;
                box-sizing: border-box;
            }

            .cmd-k-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 0.5rem;
                margin-top: 1rem;
            }

            /* Diff Viewer Styles */
            .cmd-k-diff-container {
                margin: 1rem 0;
            }

            .cmd-k-diff-display {
                background-color: var(--background-secondary);
                padding: 1rem;
                border-radius: 4px;
                font-family: var(--font-monospace);
                font-size: 0.9em;
                max-height: 400px;
                overflow-y: auto;
                white-space: pre-wrap;
                word-break: break-word;
                line-height: 1.5;
            }

            .cmd-k-diff-added {
                background-color: rgba(0, 255, 0, 0.2);
                color: var(--text-success);
                text-decoration: none;
            }

            .cmd-k-diff-removed {
                background-color: rgba(255, 0, 0, 0.2);
                color: var(--text-error);
                text-decoration: line-through;
            }

            .cmd-k-diff-unchanged {
                color: var(--text-normal);
            }

            .cmd-k-diff-stats {
                margin-top: 0.5rem;
                color: var(--text-muted);
                text-align: center;
            }

            /* Loading indicator */
            .cmd-k-loading {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 2rem;
            }

            .cmd-k-loading-spinner {
                border: 3px solid var(--background-modifier-border);
                border-top: 3px solid var(--interactive-accent);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: cmd-k-spin 1s linear infinite;
            }

            @keyframes cmd-k-spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            /* Error styles */
            .cmd-k-error {
                background-color: var(--background-modifier-error);
                color: var(--text-error);
                padding: 0.5rem;
                border-radius: 4px;
                margin: 0.5rem 0;
            }
        `;
    document.head.appendChild(styleEl);
  }
  handleEditorK() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (view) {
      const editor = view.editor;
      this.handleEditorKFromEditor(editor);
    } else {
      new import_obsidian4.Notice("Please open a note and select some text first");
    }
  }
  handleEditorKFromEditor(editor) {
    const selectedText = editor.getSelection();
    if (!selectedText) {
      new import_obsidian4.Notice("Please select some text first");
      return;
    }
    const modal = new PromptModal(
      this.app,
      selectedText,
      this.settings.savedPrompts || [],
      async (prompt) => {
        if (!this.settings.recentPrompts.includes(prompt)) {
          this.settings.recentPrompts.unshift(prompt);
          if (this.settings.recentPrompts.length > this.settings.maxRecentPrompts) {
            this.settings.recentPrompts.pop();
          }
          await this.saveSettings();
        }
        const savedPrompt = this.settings.savedPrompts.find((p) => p.prompt === prompt);
        if (savedPrompt) {
          savedPrompt.usageCount++;
          await this.saveSettings();
        }
        await this.processTextWithAI(editor, selectedText, prompt);
      },
      async (newPrompt) => {
        await this.saveSettings();
        new import_obsidian4.Notice(`Prompt "${newPrompt.name}" saved!`);
      },
      async (promptId) => {
        this.settings.savedPrompts = this.settings.savedPrompts.filter((p) => p.id !== promptId);
        await this.saveSettings();
        new import_obsidian4.Notice("Prompt deleted");
      }
    );
    modal.open();
  }
  async processTextWithAI(editor, selectedText, prompt) {
    try {
      const loadingNotice = new import_obsidian4.Notice("Processing with AI...", 0);
      const provider = this.getAIProvider();
      if (!provider.validateSettings()) {
        loadingNotice.hide();
        new import_obsidian4.Notice("Please configure your AI API key in settings");
        return;
      }
      const modifiedText = await provider.processText(selectedText, prompt);
      loadingNotice.hide();
      new DiffViewer(
        this.app,
        selectedText,
        modifiedText,
        () => {
          editor.replaceSelection(modifiedText);
          new import_obsidian4.Notice("Changes applied");
        },
        () => {
          new import_obsidian4.Notice("Changes rejected");
        }
      ).open();
    } catch (error) {
      console.error("Error processing text with AI:", error);
      new import_obsidian4.Notice(`Error: ${error instanceof Error ? error.message : "Failed to process text"}`);
    }
  }
  getAIProvider() {
    switch (this.settings.aiProvider) {
      case "openai":
        return new OpenAIProvider(
          this.settings.openaiApiKey,
          this.settings.openaiModel,
          this.settings.maxTokens
        );
      case "gemini":
        return new GeminiProvider(
          this.settings.geminiApiKey,
          this.settings.geminiModel,
          this.settings.maxTokens
        );
      case "claude":
        return new ClaudeProvider(
          this.settings.claudeApiKey,
          this.settings.claudeModel,
          this.settings.maxTokens
        );
      default:
        throw new Error(`Unknown AI provider: ${this.settings.aiProvider}`);
    }
  }
};
